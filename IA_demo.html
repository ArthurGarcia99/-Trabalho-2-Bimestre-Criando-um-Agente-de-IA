<!doctype html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Agente NL ↔ CPC </title>
  <style>
    body { font-family: Inter, system-ui, -apple-system, 'Segoe UI', Roboto, 'Helvetica Neue', Arial; background:#fff; color:#111; margin:20px; }
    .container { max-width:1100px; margin:0 auto; }
    h1 { font-size:1.6rem; }
    .grid { display:grid; grid-template-columns: 1fr 320px; gap:16px; }
    .card { border:1px solid #e6e6e6; border-radius:10px; padding:12px; background:#fafafa; }
    textarea, input[type=text] { width:100%; font-family:monospace; padding:8px; border-radius:6px; border:1px solid #ddd; }
    .row { display:flex; gap:8px; align-items:center; }
    button { padding:6px 10px; border-radius:6px; border:1px solid #ccc; background:#fff; cursor:pointer; }
    .muted { color:#666; font-size:0.9rem; }
    table { border-collapse:collapse; width:100%; }
    th, td { border:1px solid #ddd; padding:6px; text-align:center; font-family:monospace; }
    .small { font-size:0.9rem; }
    /* Modal de confirmação de átomos */
    .modal-backdrop { position:fixed; inset:0; background:rgba(0,0,0,0.35); display:flex; align-items:center; justify-content:center; z-index:9999; }
    .modal { background:#fff; border-radius:8px; padding:16px; width:720px; max-width:95%; box-shadow:0 6px 24px rgba(0,0,0,0.2); }
    .modal h3 { margin:0 0 8px 0; }
    .modal .atoms { max-height:320px; overflow:auto; display:flex; flex-direction:column; gap:8px; margin-bottom:10px; }
    .modal .atom-row { display:flex; gap:8px; align-items:center; }
    .modal .atom-row input[type=text] { flex:1; }
    .modal .modal-actions { display:flex; gap:8px; justify-content:flex-end; }
  </style>
</head>
<body>
  <div class="container">
    <h1>Agente NL ↔ CPC </h1>

    <div class="grid" style="margin-top:12px;">
      <div>
        <div class="card">
          <label for="nl"><strong>Sentença (Português)</strong></label>
          <textarea id="nl" rows="4" placeholder="Ex.: Se está chovendo, então levarei guarda-chuva."></textarea>

          <!-- Removida opção de extração automática: o dicionário deve ser sempre preenchido manualmente -->

          <div class="row" style="margin-top:8px;">
            <button id="toCPC">Traduzir para CPC</button>
            <button id="clearNL">Limpar</button>
            <button id="copyNL">Copiar NL</button>
          </div>

          <div style="margin-top:10px;">
            <label><strong>Fórmula</strong></label>
            <input id="formula" type="text" placeholder="Resultado aparecerá aqui (ex.: A → B)" />
            <div style="margin-top:6px;" class="row">
              <button id="copyFormula">Copiar fórmula</button>
              <button id="toNL">Gerar sentença em PT-BR</button>
            </div>
          </div>
        </div>

        <div class="card" style="margin-top:12px;">
          <strong>Exemplos rápidos</strong>
          <div class="small muted">Clique em carregar para substituir NL/Fórmula/Dicionário</div>
          <div id="examples" style="margin-top:8px; display:grid; gap:8px;"></div>
        </div>

        <!-- Tabela-verdade removida nesta versão demo -->
      </div>

      <div>
        <div class="card">
          <div style="display:flex; justify-content:space-between; align-items:center;"><strong>Dicionário de átomos</strong>
            <div>
              <button id="addAtom">Adicionar</button>
              <button id="resetDict">Padrão</button>
            </div>
          </div>
          <div class="small muted">Mapeie letras (A, B, C, ...) para proposições em PT-BR.</div>
          <div id="dictList" style="margin-top:8px; display:flex; flex-direction:column; gap:8px; max-height:420px; overflow:auto;"></div>
        </div>

        <div class="card" style="margin-top:12px;">
          <strong>Conectivos suportados</strong>
          <ul class="small">
            <li>¬ negação — "não", "não é verdade que"</li>
            <li>∧ conjunção — "e", "mas"</li>
            <li>∨ disjunção — "ou"</li>
            <li>⊕ disjunção exclusiva — "ou ... ou ... (mas não ambos)"</li>
            <li>→ condicional — "se ..., então ..."; "X somente se Y" ⇒ X → Y</li>
            <li>↔ bicondicional — "se e somente se", "ssi"</li>
          </ul>
          <p class="small muted">Precedência: ¬ &gt; ∧ &gt; (∨, ⊕) &gt; → &gt; ↔.</p>
        </div>
      </div>
    </div>
  </div>

  <!-- Modal de confirmação (criado dinamicamente pelo JS, mas manter container vazio como fallback) -->
  <div id="confirmModalContainer"></div>

<script>
// --- Core logic copied/adapted from original component ---
const LETTERS = "ABCDEFGHIJKLMNOPQRSTUVWXYZ".split("");
const strip = (s) => s.replace(/\s+/g, " ").trim();
const lc = (s) => s.toLowerCase();
const uniq = (arr) => Array.from(new Set(arr));
const copyToClipboard = async (text) => { try { await navigator.clipboard.writeText(text); } catch (e) { alert('Falha ao copiar: '+e); } };

function tokenizeFormula(src) {
  let s = src
    .replace(/<->|<=>/g, "↔")
    .replace(/->/g, "→")
    .replace(/\bxor\b/gi, "⊕")
    .replace(/\biff\b/gi, "↔")
    .replace(/\bimplies\b/gi, "→")
    .replace(/[\s\t\n]+/g, " ")
    .trim();

  const tokens = [];
  let i = 0;
  while (i < s.length) {
    const c = s[i];
    if (c === " ") { i++; continue; }
    if (/[A-Za-z]/.test(c)) {
      let j = i + 1;
      while (j < s.length && /[A-Za-z0-9_]/.test(s[j])) j++;
      tokens.push({ type: "id", value: s.slice(i, j).toUpperCase() });
      i = j; continue;
    }
    const map = {"¬":"NOT","!":"NOT","~":"NOT","∧":"AND","&":"AND","^":"AND","∨":"OR","|":"OR","v":"OR","⊕":"XOR","→":"IMP","↔":"IFF","(":"LP", ")":"RP"};
    if (map[c]) { tokens.push({ type: map[c], value: c }); i++; continue; }
    throw new Error(`Símbolo inválido: "${c}"`);
  }
  return tokens;
}

const PRECEDENCE = { IFF:1, IMP:2, OR:3, XOR:3, AND:4, NOT:5 };
function parseFormula(tokens) {
  let pos = 0; const peek = () => tokens[pos]; const eat = () => tokens[pos++];
  function parseAtom() {
    const t = peek(); if (!t) throw new Error('Fim inesperado');
    if (t.type === 'LP') { eat(); const e = parseExpr(0); if (!peek() || peek().type !== 'RP') throw new Error('Parêntese não fechado'); eat(); return e; }
    if (t.type === 'NOT') { eat(); return { type: 'NOT', sub: parseAtom() }; }
    if (t.type === 'id') { eat(); return { type: 'ID', name: t.value }; }
    throw new Error(`Token inesperado: ${t.type}`);
  }
  function lbp(type) { return PRECEDENCE[type] || 0; }
  function parseExpr(minBp) {
    let left = parseAtom();
    while (true) {
      const t = peek(); if (!t) break;
      if (["AND","OR","XOR","IMP","IFF"].includes(t.type) && lbp(t.type) >= minBp) {
        const op = t.type; eat(); const right = parseExpr(lbp(op) + 1); left = { type: op, left, right }; continue;
      }
      break;
    }
    return left;
  }
  const ast = parseExpr(0);
  if (pos !== tokens.length) throw new Error('Tokens extras após o fim da fórmula');
  return ast;
}

function evalAST(ast, val) {
  switch (ast.type) {
    case 'ID': return !!val[ast.name];
    case 'NOT': return !evalAST(ast.sub, val);
    case 'AND': return evalAST(ast.left, val) && evalAST(ast.right, val);
    case 'OR': return evalAST(ast.left, val) || evalAST(ast.right, val);
    case 'XOR': return !!(evalAST(ast.left, val) ^ evalAST(ast.right, val));
    case 'IMP': return (!evalAST(ast.left, val)) || evalAST(ast.right, val);
    case 'IFF': return evalAST(ast.left, val) === evalAST(ast.right, val);
    default: throw new Error('AST inválida');
  }
}
// collectAtoms removed (used only for truth table which is disabled in this demo)
function astToFormula(ast) {
  const prec = (t) => PRECEDENCE[t] || 9;
  switch (ast.type) {
    case 'ID': return ast.name;
    case 'NOT': {
      const inner = ast.sub; const s = astToFormula(inner);
      const needs = prec(inner.type) > prec('NOT') ? false : inner.type !== 'ID';
      return `¬${needs ? `(${s})` : s}`;
    }
    default: {
      const opMap = { AND:'∧', OR:'∨', XOR:'⊕', IMP:'→', IFF:'↔' };
      const L = ast.left, R = ast.right; const l = astToFormula(L), r = astToFormula(R);
      const lp = prec(L.type) < prec(ast.type) ? `(${l})` : l;
      const rp = prec(R.type) < prec(ast.type) ? `(${r})` : r;
      return `${lp} ${opMap[ast.type]} ${rp}`;
    }
  }
}

// NL helpers
function normalizeNL(text) {
  let s = " " + lc(text) + " ";
  s = s.replace(/[.,;:!?]+/g, " ");
  s = s.replace(/\bmas\b/g, " e ");
  s = s.replace(/\bssi\b/g, " se e somente se ");
  s = s.replace(/\bsomente se\b/g, " somente se ");
  s = s.replace(/\bapenas se\b/g, " somente se ");
  s = s.replace(/\bse,? e somente se\b/g, " se e somente se ");
  s = s.replace(/\bse e somente se\b/g, " se e somente se ");
  s = s.replace(/\bnao\b/g, " não ");
  s = s.replace(/\bn\u00e3o\b/g, " não ");
  s = s.replace(/\s+/g, " ").trim();
  return s;
}

// --- Modal / interação para confirmação dos átomos extraídos ---
function showConfirmAtoms(initialDict) {
  return new Promise((resolve) => {
    const container = document.getElementById('confirmModalContainer');
    container.innerHTML = '';
    const backdrop = document.createElement('div'); backdrop.className = 'modal-backdrop';
    const modal = document.createElement('div'); modal.className = 'modal';
    const title = document.createElement('h3'); title.textContent = 'Confirmar/editar átomos extraídos';
    modal.appendChild(title);
    const info = document.createElement('div'); info.className = 'small muted'; info.style.marginBottom='8px'; info.textContent = 'Revise os átomos extraídos e edite se necessário. Apague um valor para removê-lo.';
    modal.appendChild(info);
    const atomsBox = document.createElement('div'); atomsBox.className = 'atoms';

    // inicializar linhas a partir do dicionário
    for (const [k,v] of Object.entries(initialDict)) {
      const row = document.createElement('div'); row.className = 'atom-row';
      const key = document.createElement('div'); key.style.width='36px'; key.style.fontFamily='monospace'; key.textContent = k;
      const input = document.createElement('input'); input.type='text'; input.value = v; input.dataset.letter = k;
      const del = document.createElement('button'); del.textContent='✖'; del.title='Remover'; del.onclick = () => input.value = '';
      row.appendChild(key); row.appendChild(input); row.appendChild(del); atomsBox.appendChild(row);
    }

    // botão para adicionar novo átomo
    const addRowBtn = document.createElement('button'); addRowBtn.textContent = 'Adicionar átomo'; addRowBtn.onclick = () => {
      // achar próxima letra disponível
      const used = new Set(Array.from(atomsBox.querySelectorAll('input')).map(i=>i.dataset.letter));
      const next = LETTERS.find(L => !used.has(L));
      if (!next) return alert('Limite de átomos atingido');
      const row = document.createElement('div'); row.className='atom-row';
      const key = document.createElement('div'); key.style.width='36px'; key.style.fontFamily='monospace'; key.textContent = next;
      const input = document.createElement('input'); input.type='text'; input.value = ''; input.dataset.letter = next;
      const del = document.createElement('button'); del.textContent='✖'; del.title='Remover'; del.onclick = () => input.value = '';
      row.appendChild(key); row.appendChild(input); row.appendChild(del); atomsBox.appendChild(row);
      input.focus();
    };

    modal.appendChild(atomsBox);
    modal.appendChild(addRowBtn);

    const actions = document.createElement('div'); actions.className = 'modal-actions';
    const cancel = document.createElement('button'); cancel.textContent = 'Cancelar'; cancel.onclick = () => { container.removeChild(backdrop); resolve(null); };
    const accept = document.createElement('button'); accept.textContent = 'Confirmar'; accept.onclick = () => {
      // construir dicionário a partir dos inputs
      const out = {};
      for (const inp of atomsBox.querySelectorAll('input')) {
        const letter = inp.dataset.letter; const val = inp.value.trim();
        if (val) out[letter] = val;
      }
      container.removeChild(backdrop);
      resolve(out);
    };
    actions.appendChild(cancel); actions.appendChild(accept); modal.appendChild(actions);

    backdrop.appendChild(modal); container.appendChild(backdrop);
  });
}
function escapeRegex(s) { return s.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"); }
function extractAtomsFromNL(text) {
  const s = normalizeNL(text);
  const CONNECTIVES = [" se e somente se ", " se ", " então ", " somente se ", " e ", " ou "];
  let parts = [s];
  for (const c of CONNECTIVES) parts = parts.flatMap(p => p.split(c));
  const clauses = uniq(parts.map(strip).filter(x => x.length > 0));
  return clauses.map(c => c.replace(/^não (é verdade que )?/i, "").trim());
}
function buildDictionaryFromNL(text) {
  const atoms = extractAtomsFromNL(text);
  const map = {};
  atoms.forEach((clause, idx) => { const letter = LETTERS[idx] || `P${idx+1}`; map[letter] = clause; });
  return map;
}
function nlToFormula(text, dict) {
  let s = normalizeNL(text);
  const entries = Object.entries(dict).filter(([, v]) => v && v.trim().length).sort((a,b) => b[1].length - a[1].length);
  for (const [k,v] of entries) { const re = new RegExp(`\\b${escapeRegex(lc(v))}\\b`, "g"); s = s.replace(re, ` ${k} `); }
  s = s.replace(/\bnão é verdade que\s+(\w+)\b/g, " ¬$1 ");
  s = s.replace(/\bnão\s+\(\s*([^\)]+)\s*\)/g, " ¬($1) ");
  s = s.replace(/\bnão\s+(\w+)\b/g, " ¬$1 ");
  s = s.replace(/\bse e somente se\b/g, " ↔ ");
  s = s.replace(/\bse\s+([^]+?)\s*então\s+([^]+)$/g, (m,p,q) => ` ( ${p} ) → ( ${q} ) `);
  s = s.replace(/\b(\w+)\s+somente se\s+(\w+)\b/g, " ($1) → ($2) ");
  s = s.replace(/\bou\s+(\w+)\s+ou\s+(\w+)\b/g, " ($1) ⊕ ($2) ");
  s = s.replace(/\se\b/g, " ∧ ");
  s = s.replace(/\bou\b/g, " ∨ ");
  s = s.replace(/\s+/g, " ").trim();
  s = s.replace(/\b([A-Z][A-Z0-9_]*)\b/g, (m) => m.toUpperCase());
  return s;
}

function realizePT(ast, dict) {
  const name = (id) => dict && dict[id] ? dict[id] : id;
  function paren(s) { if (/\b(e|ou|então|somente|ambos)\b|,/.test(lc(s))) return `(${s})`; return s; }
  function go(node) {
    switch (node.type) {
      case 'ID': return name(node.name);
      case 'NOT': return `Não é verdade que ${paren(go(node.sub))}`;
      case 'AND': return `${paren(go(node.left))} e ${paren(go(node.right))}`;
      case 'OR': return `${paren(go(node.left))} ou ${paren(go(node.right))}`;
      case 'XOR': return `${paren(go(node.left))} ou ${paren(go(node.right))} (mas não ambos)`;
      case 'IMP': return `Se ${paren(go(node.left))}, então ${paren(go(node.right))}`;
      case 'IFF': return `${paren(go(node.left))} se e somente se ${paren(go(node.right))}`;
      default: return '?';
    }
  }
  return go(ast);
}

// --- UI wiring ---
const nlEl = document.getElementById('nl');
const formulaEl = document.getElementById('formula');
const dictListEl = document.getElementById('dictList');
const examplesEl = document.getElementById('examples');

// Dicionário obrigatório: sempre use o dicionário manual de átomos
let dict = { A: "está chovendo", B: "levarei guarda-chuva", C: "a rua está molhada" };

function renderDictUI() {
  dictListEl.innerHTML = '';
  // Sempre usar o dicionário manual (não extrair automaticamente a partir do NL)
  const cur = dict;
  const entries = Object.entries(cur);
  if (entries.length === 0) {
    dictListEl.innerHTML = '<div class="muted small">Nenhum átomo definido.</div>';
    return;
  }
  for (const [k,v] of entries) {
    const row = document.createElement('div'); row.style.display='flex'; row.style.gap='8px'; row.style.alignItems='center';
    const span = document.createElement('div'); span.style.width='32px'; span.style.fontFamily='monospace'; span.textContent = k;
    const input = document.createElement('input'); input.type='text'; input.value = v; input.style.flex='1'; input.oninput = (e) => { dict[k] = e.target.value; renderDictUI(); };
    const del = document.createElement('button'); del.textContent='✖'; del.title='Remover'; del.onclick = () => { delete dict[k]; renderDictUI(); };
    row.appendChild(span); row.appendChild(input); row.appendChild(del); dictListEl.appendChild(row);
  }
}
function addDict() {
  const next = LETTERS.find(L => !dict[L]); if (!next) return; dict[next] = '';
  renderDictUI();
}
function resetDict() { dict = { A: "está chovendo", B: "levarei guarda-chuva", C: "a rua está molhada" }; renderDictUI(); }

// examples
const examples = [
  { nl: 'Se está chovendo, então levarei guarda-chuva.', dict: { A: 'está chovendo', B: 'levarei guarda-chuva' }, f: 'A → B' },
  { nl: 'Ou João estuda ou Maria passa (mas não ambos).', dict: { A: 'João estuda', B: 'Maria passa' }, f: 'A ⊕ B' },
  { nl: 'Não é verdade que a rua está molhada e está ventando.', dict: { A: 'a rua está molhada', B: 'está ventando' }, f: '¬(A ∧ B)' },
  { nl: 'Se Pedro vai ao cinema, então Ana vai ao teatro', dict: { A: 'Pedro vai ao cinema', B: 'Ana vai ao teatro' }, f: 'A → B' },
  { nl: 'Carlos passa se e somente se estuda.', dict: { A: 'Carlos passa', B: 'estuda' }, f: 'A ↔ B' }
];
function renderExamples() {
  examplesEl.innerHTML = '';
  for (const ex of examples) {
    const c = document.createElement('div'); c.className='card'; c.style.padding='8px'; c.style.background='white'; c.style.border='1px solid #eee';
    c.innerHTML = `<div style="font-size:0.9rem;"><strong>NL</strong><div>${ex.nl}</div><div style="margin-top:6px;font-family:monospace;">${Object.entries(ex.dict).map(([k,v])=>`${k}: ${v}`).join('; ')}</div><div style="margin-top:6px; font-family:monospace;">${ex.f}</div></div>`;
    const btnRow = document.createElement('div'); btnRow.style.marginTop='8px'; btnRow.style.display='flex'; btnRow.style.gap='8px';
    const load = document.createElement('button'); load.textContent='Carregar'; load.onclick = () => { nlEl.value = ex.nl; formulaEl.value = ex.f; dict = { ...ex.dict }; renderDictUI(); };
    const copyBtn = document.createElement('button'); copyBtn.textContent='Copiar'; copyBtn.onclick = () => copyToClipboard(ex.f);
    btnRow.appendChild(load); btnRow.appendChild(copyBtn); c.appendChild(btnRow); examplesEl.appendChild(c);
  }
}

// actions
function handleNLtoCPC() {
  try {
    // Extrair candidatos automaticamente e pedir confirmação ao usuário
    const candidates = buildDictionaryFromNL(nlEl.value || '');
    showConfirmAtoms(candidates).then((confirmed) => {
      if (!confirmed) return; // usuário cancelou
      // aplicar dicionário confirmado e traduzir
      dict = { ...confirmed };
      const f = nlToFormula(nlEl.value || '', dict);
      formulaEl.value = f; renderDictUI();
    }).catch((err) => { alert('Erro: '+err.message); });
  } catch (e) { alert('Erro: '+e.message); }
}
function handleCPCtoNL() {
  try {
    const tokens = tokenizeFormula(formulaEl.value || '');
    const ast = parseFormula(tokens);
    const out = realizePT(ast, dict);
    nlEl.value = out;
  } catch (e) { alert('Erro: '+e.message); }
}

// renderTable removed (tabela-verdade não é exibida nesta demo)

// wire buttons
document.getElementById('toCPC').onclick = handleNLtoCPC;
document.getElementById('clearNL').onclick = () => { nlEl.value=''; formulaEl.value=''; };
document.getElementById('copyNL').onclick = () => copyToClipboard(nlEl.value);
document.getElementById('copyFormula').onclick = () => copyToClipboard(formulaEl.value);
document.getElementById('addAtom').onclick = addDict;
document.getElementById('resetDict').onclick = resetDict;
// showTable control removed
document.getElementById('toNL').onclick = handleCPCtoNL;

// initial render
renderDictUI(); renderExamples();

// expose some actions for convenience
window.translateCPCtoNL = handleCPCtoNL;
</script>
</body>
</html>